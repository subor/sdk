/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CommonTypeSDKDataTypes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Ruyi { namespace SDK { namespace CommonType {

int _kLoginStateValues[] = {
  LoginState::Logout,
  LoginState::Login
};
const char* _kLoginStateNames[] = {
  "Logout",
  "Login"
};
const std::map<int, const char*> _LoginState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLoginStateValues, _kLoginStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LoginState::type& val) {
  std::map<int, const char*>::const_iterator it = _LoginState_VALUES_TO_NAMES.find(val);
  if (it != _LoginState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kNotificationTypeValues[] = {
  NotificationType::Battery,
  NotificationType::Interactive,
  NotificationType::Voice,
  NotificationType::GameInfo,
  NotificationType::ScreenshotInfo
};
const char* _kNotificationTypeNames[] = {
  "Battery",
  "Interactive",
  "Voice",
  "GameInfo",
  "ScreenshotInfo"
};
const std::map<int, const char*> _NotificationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kNotificationTypeValues, _kNotificationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NotificationType::type& val) {
  std::map<int, const char*>::const_iterator it = _NotificationType_VALUES_TO_NAMES.find(val);
  if (it != _NotificationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kInputCategoryValues[] = {
  InputCategory::GamePad,
  InputCategory::Keyboard,
  InputCategory::Mouse,
  InputCategory::JoyStick,
  InputCategory::MaxCount
};
const char* _kInputCategoryNames[] = {
  "GamePad",
  "Keyboard",
  "Mouse",
  "JoyStick",
  "MaxCount"
};
const std::map<int, const char*> _InputCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kInputCategoryValues, _kInputCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const InputCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _InputCategory_VALUES_TO_NAMES.find(val);
  if (it != _InputCategory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kRuyiGamePadButtonFlagsValues[] = {
  RuyiGamePadButtonFlags::GamePad_Up,
  RuyiGamePadButtonFlags::GamePad_Down,
  RuyiGamePadButtonFlags::GamePad_Left,
  RuyiGamePadButtonFlags::GamePad_Right,
  RuyiGamePadButtonFlags::GamePad_Start,
  RuyiGamePadButtonFlags::GamePad_Back,
  RuyiGamePadButtonFlags::GamePad_L3,
  RuyiGamePadButtonFlags::GamePad_R3,
  RuyiGamePadButtonFlags::GamePad_LB,
  RuyiGamePadButtonFlags::GamePad_RB,
  RuyiGamePadButtonFlags::GamePad_A,
  RuyiGamePadButtonFlags::GamePad_B,
  RuyiGamePadButtonFlags::GamePad_X,
  RuyiGamePadButtonFlags::GamePad_Y,
  RuyiGamePadButtonFlags::GamePad_LT,
  RuyiGamePadButtonFlags::GamePad_RT,
  RuyiGamePadButtonFlags::GamePad_LJoyX,
  RuyiGamePadButtonFlags::GamePad_LJoyY,
  RuyiGamePadButtonFlags::GamePad_RJoyX,
  RuyiGamePadButtonFlags::GamePad_RJoyY
};
const char* _kRuyiGamePadButtonFlagsNames[] = {
  "GamePad_Up",
  "GamePad_Down",
  "GamePad_Left",
  "GamePad_Right",
  "GamePad_Start",
  "GamePad_Back",
  "GamePad_L3",
  "GamePad_R3",
  "GamePad_LB",
  "GamePad_RB",
  "GamePad_A",
  "GamePad_B",
  "GamePad_X",
  "GamePad_Y",
  "GamePad_LT",
  "GamePad_RT",
  "GamePad_LJoyX",
  "GamePad_LJoyY",
  "GamePad_RJoyX",
  "GamePad_RJoyY"
};
const std::map<int, const char*> _RuyiGamePadButtonFlags_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kRuyiGamePadButtonFlagsValues, _kRuyiGamePadButtonFlagsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RuyiGamePadButtonFlags::type& val) {
  std::map<int, const char*>::const_iterator it = _RuyiGamePadButtonFlags_VALUES_TO_NAMES.find(val);
  if (it != _RuyiGamePadButtonFlags_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kePlatformValues[] = {
  ePlatform::None,
  ePlatform::PC,
  ePlatform::Console,
  ePlatform::All
};
const char* _kePlatformNames[] = {
  "None",
  "PC",
  "Console",
  "All"
};
const std::map<int, const char*> _ePlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kePlatformValues, _kePlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ePlatform::type& val) {
  std::map<int, const char*>::const_iterator it = _ePlatform_VALUES_TO_NAMES.find(val);
  if (it != _ePlatform_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _keUITypeValues[] = {
  eUIType::None,
  eUIType::Toggle,
  eUIType::Text,
  eUIType::Slider,
  eUIType::CheckList,
  eUIType::OptionList,
  eUIType::DateTime,
  eUIType::TextInput
};
const char* _keUITypeNames[] = {
  "None",
  "Toggle",
  "Text",
  "Slider",
  "CheckList",
  "OptionList",
  "DateTime",
  "TextInput"
};
const std::map<int, const char*> _eUIType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _keUITypeValues, _keUITypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const eUIType::type& val) {
  std::map<int, const char*>::const_iterator it = _eUIType_VALUES_TO_NAMES.find(val);
  if (it != _eUIType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


ErrorException::~ErrorException() throw() {
}


void ErrorException::__set_errId(const int32_t val) {
  this->errId = val;
}

void ErrorException::__set_errMsg(const std::string& val) {
  this->errMsg = val;
}
std::ostream& operator<<(std::ostream& out, const ErrorException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ErrorException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errId);
          this->__isset.errId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ErrorException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ErrorException");

  xfer += oprot->writeFieldBegin("errId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->errMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ErrorException &a, ErrorException &b) {
  using ::std::swap;
  swap(a.errId, b.errId);
  swap(a.errMsg, b.errMsg);
  swap(a.__isset, b.__isset);
}

ErrorException::ErrorException(const ErrorException& other0) : TException() {
  errId = other0.errId;
  errMsg = other0.errMsg;
  __isset = other0.__isset;
}
ErrorException& ErrorException::operator=(const ErrorException& other1) {
  errId = other1.errId;
  errMsg = other1.errMsg;
  __isset = other1.__isset;
  return *this;
}
void ErrorException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ErrorException(";
  out << "errId=" << to_string(errId);
  out << ", " << "errMsg=" << to_string(errMsg);
  out << ")";
}

const char* ErrorException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ErrorException";
  }
}


range::~range() throw() {
}


void range::__set_minimum(const double val) {
  this->minimum = val;
}

void range::__set_maximum(const double val) {
  this->maximum = val;
}
std::ostream& operator<<(std::ostream& out, const range& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t range::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->minimum);
          this->__isset.minimum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->maximum);
          this->__isset.maximum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("range");

  xfer += oprot->writeFieldBegin("minimum", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->minimum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maximum", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->maximum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(range &a, range &b) {
  using ::std::swap;
  swap(a.minimum, b.minimum);
  swap(a.maximum, b.maximum);
  swap(a.__isset, b.__isset);
}

range::range(const range& other2) {
  minimum = other2.minimum;
  maximum = other2.maximum;
  __isset = other2.__isset;
}
range& range::operator=(const range& other3) {
  minimum = other3.minimum;
  maximum = other3.maximum;
  __isset = other3.__isset;
  return *this;
}
void range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "range(";
  out << "minimum=" << to_string(minimum);
  out << ", " << "maximum=" << to_string(maximum);
  out << ")";
}


InputModifier::~InputModifier() throw() {
}


void InputModifier::__set_DeadZone(const range& val) {
  this->DeadZone = val;
__isset.DeadZone = true;
}

void InputModifier::__set_Scale(const double val) {
  this->Scale = val;
}
std::ostream& operator<<(std::ostream& out, const InputModifier& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InputModifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->DeadZone.read(iprot);
          this->__isset.DeadZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Scale);
          this->__isset.Scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputModifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputModifier");

  if (this->__isset.DeadZone) {
    xfer += oprot->writeFieldBegin("DeadZone", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->DeadZone.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("Scale", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputModifier &a, InputModifier &b) {
  using ::std::swap;
  swap(a.DeadZone, b.DeadZone);
  swap(a.Scale, b.Scale);
  swap(a.__isset, b.__isset);
}

InputModifier::InputModifier(const InputModifier& other4) {
  DeadZone = other4.DeadZone;
  Scale = other4.Scale;
  __isset = other4.__isset;
}
InputModifier& InputModifier::operator=(const InputModifier& other5) {
  DeadZone = other5.DeadZone;
  Scale = other5.Scale;
  __isset = other5.__isset;
  return *this;
}
void InputModifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputModifier(";
  out << "DeadZone="; (__isset.DeadZone ? (out << to_string(DeadZone)) : (out << "<null>"));
  out << ", " << "Scale=" << to_string(Scale);
  out << ")";
}


ActionTrigger::~ActionTrigger() throw() {
}


void ActionTrigger::__set_Id(const int32_t val) {
  this->Id = val;
}

void ActionTrigger::__set_InputCagetory(const InputCategory::type val) {
  this->InputCagetory = val;
}

void ActionTrigger::__set_TriggerButtons(const std::vector<int32_t> & val) {
  this->TriggerButtons = val;
}

void ActionTrigger::__set_TriggerValue(const std::vector<int32_t> & val) {
  this->TriggerValue = val;
}
std::ostream& operator<<(std::ostream& out, const ActionTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ActionTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->Id);
          this->__isset.Id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->InputCagetory = (InputCategory::type)ecast6;
          this->__isset.InputCagetory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->TriggerButtons.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->TriggerButtons.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readI32(this->TriggerButtons[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.TriggerButtons = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->TriggerValue.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->TriggerValue.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readI32(this->TriggerValue[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.TriggerValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionTrigger");

  xfer += oprot->writeFieldBegin("Id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->Id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("InputCagetory", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->InputCagetory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerButtons", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->TriggerButtons.size()));
    std::vector<int32_t> ::const_iterator _iter17;
    for (_iter17 = this->TriggerButtons.begin(); _iter17 != this->TriggerButtons.end(); ++_iter17)
    {
      xfer += oprot->writeI32((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerValue", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->TriggerValue.size()));
    std::vector<int32_t> ::const_iterator _iter18;
    for (_iter18 = this->TriggerValue.begin(); _iter18 != this->TriggerValue.end(); ++_iter18)
    {
      xfer += oprot->writeI32((*_iter18));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionTrigger &a, ActionTrigger &b) {
  using ::std::swap;
  swap(a.Id, b.Id);
  swap(a.InputCagetory, b.InputCagetory);
  swap(a.TriggerButtons, b.TriggerButtons);
  swap(a.TriggerValue, b.TriggerValue);
  swap(a.__isset, b.__isset);
}

ActionTrigger::ActionTrigger(const ActionTrigger& other19) {
  Id = other19.Id;
  InputCagetory = other19.InputCagetory;
  TriggerButtons = other19.TriggerButtons;
  TriggerValue = other19.TriggerValue;
  __isset = other19.__isset;
}
ActionTrigger& ActionTrigger::operator=(const ActionTrigger& other20) {
  Id = other20.Id;
  InputCagetory = other20.InputCagetory;
  TriggerButtons = other20.TriggerButtons;
  TriggerValue = other20.TriggerValue;
  __isset = other20.__isset;
  return *this;
}
void ActionTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionTrigger(";
  out << "Id=" << to_string(Id);
  out << ", " << "InputCagetory=" << to_string(InputCagetory);
  out << ", " << "TriggerButtons=" << to_string(TriggerButtons);
  out << ", " << "TriggerValue=" << to_string(TriggerValue);
  out << ")";
}


notification::~notification() throw() {
}


void notification::__set_title(const std::string& val) {
  this->title = val;
}

void notification::__set_detail(const std::string& val) {
  this->detail = val;
}

void notification::__set_option(const std::vector<std::string> & val) {
  this->option = val;
}
std::ostream& operator<<(std::ostream& out, const notification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t notification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->detail);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->option.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->option.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->option[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notification");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->option.size()));
    std::vector<std::string> ::const_iterator _iter26;
    for (_iter26 = this->option.begin(); _iter26 != this->option.end(); ++_iter26)
    {
      xfer += oprot->writeString((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notification &a, notification &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.detail, b.detail);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

notification::notification(const notification& other27) {
  title = other27.title;
  detail = other27.detail;
  option = other27.option;
  __isset = other27.__isset;
}
notification& notification::operator=(const notification& other28) {
  title = other28.title;
  detail = other28.detail;
  option = other28.option;
  __isset = other28.__isset;
  return *this;
}
void notification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notification(";
  out << "title=" << to_string(title);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


dataListItem::~dataListItem() throw() {
}


void dataListItem::__set_elementType(const std::string& val) {
  this->elementType = val;
}

void dataListItem::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void dataListItem::__set_removeNotification(const notification& val) {
  this->removeNotification = val;
}
std::ostream& operator<<(std::ostream& out, const dataListItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t dataListItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->elementType);
          this->__isset.elementType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->values.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readString(this->values[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->removeNotification.read(iprot);
          this->__isset.removeNotification = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t dataListItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("dataListItem");

  xfer += oprot->writeFieldBegin("elementType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->elementType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter34;
    for (_iter34 = this->values.begin(); _iter34 != this->values.end(); ++_iter34)
    {
      xfer += oprot->writeString((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removeNotification", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->removeNotification.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(dataListItem &a, dataListItem &b) {
  using ::std::swap;
  swap(a.elementType, b.elementType);
  swap(a.values, b.values);
  swap(a.removeNotification, b.removeNotification);
  swap(a.__isset, b.__isset);
}

dataListItem::dataListItem(const dataListItem& other35) {
  elementType = other35.elementType;
  values = other35.values;
  removeNotification = other35.removeNotification;
  __isset = other35.__isset;
}
dataListItem& dataListItem::operator=(const dataListItem& other36) {
  elementType = other36.elementType;
  values = other36.values;
  removeNotification = other36.removeNotification;
  __isset = other36.__isset;
  return *this;
}
void dataListItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "dataListItem(";
  out << "elementType=" << to_string(elementType);
  out << ", " << "values=" << to_string(values);
  out << ", " << "removeNotification=" << to_string(removeNotification);
  out << ")";
}


activeDependency::~activeDependency() throw() {
}


void activeDependency::__set_name(const std::string& val) {
  this->name = val;
}

void activeDependency::__set_condition(const std::string& val) {
  this->condition = val;
}
std::ostream& operator<<(std::ostream& out, const activeDependency& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t activeDependency::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->condition);
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t activeDependency::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("activeDependency");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->condition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(activeDependency &a, activeDependency &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.condition, b.condition);
  swap(a.__isset, b.__isset);
}

activeDependency::activeDependency(const activeDependency& other37) {
  name = other37.name;
  condition = other37.condition;
  __isset = other37.__isset;
}
activeDependency& activeDependency::operator=(const activeDependency& other38) {
  name = other38.name;
  condition = other38.condition;
  __isset = other38.__isset;
  return *this;
}
void activeDependency::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "activeDependency(";
  out << "name=" << to_string(name);
  out << ", " << "condition=" << to_string(condition);
  out << ")";
}


SettingValue::~SettingValue() throw() {
}


void SettingValue::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingValue::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}
std::ostream& operator<<(std::ostream& out, const SettingValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingValue");

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingValue &a, SettingValue &b) {
  using ::std::swap;
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.__isset, b.__isset);
}

SettingValue::SettingValue(const SettingValue& other39) {
  dataType = other39.dataType;
  dataValue = other39.dataValue;
  __isset = other39.__isset;
}
SettingValue& SettingValue::operator=(const SettingValue& other40) {
  dataType = other40.dataType;
  dataValue = other40.dataValue;
  __isset = other40.__isset;
  return *this;
}
void SettingValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingValue(";
  out << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ")";
}


SettingItem::~SettingItem() throw() {
}


void SettingItem::__set_id(const std::string& val) {
  this->id = val;
}

void SettingItem::__set_display(const std::string& val) {
  this->display = val;
}

void SettingItem::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingItem::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}

void SettingItem::__set_dataList(const dataListItem& val) {
  this->dataList = val;
__isset.dataList = true;
}

void SettingItem::__set_platform(const ePlatform::type val) {
  this->platform = val;
__isset.platform = true;
}

void SettingItem::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingItem::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingItem::__set_UIType(const eUIType::type val) {
  this->UIType = val;
__isset.UIType = true;
}

void SettingItem::__set_devModeOnly(const bool val) {
  this->devModeOnly = val;
__isset.devModeOnly = true;
}

void SettingItem::__set_internalOnly(const bool val) {
  this->internalOnly = val;
__isset.internalOnly = true;
}

void SettingItem::__set_readOnly(const bool val) {
  this->readOnly = val;
__isset.readOnly = true;
}

void SettingItem::__set_isValid(const bool val) {
  this->isValid = val;
}

void SettingItem::__set_isActive(const bool val) {
  this->isActive = val;
}

void SettingItem::__set_validation(const std::string& val) {
  this->validation = val;
__isset.validation = true;
}

void SettingItem::__set_activeDependencies(const std::vector<activeDependency> & val) {
  this->activeDependencies = val;
__isset.activeDependencies = true;
}

void SettingItem::__set_ActionName(const std::string& val) {
  this->ActionName = val;
__isset.ActionName = true;
}

void SettingItem::__set_ActionObject(const std::string& val) {
  this->ActionObject = val;
__isset.ActionObject = true;
}

void SettingItem::__set_ActionOnSetValue(const std::string& val) {
  this->ActionOnSetValue = val;
__isset.ActionOnSetValue = true;
}

void SettingItem::__set_ActionOnGetValue(const std::string& val) {
  this->ActionOnGetValue = val;
__isset.ActionOnGetValue = true;
}
std::ostream& operator<<(std::ostream& out, const SettingItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataList.read(iprot);
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast41;
          xfer += iprot->readI32(ecast41);
          this->platform = (ePlatform::type)ecast41;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->UIType = (eUIType::type)ecast42;
          this->__isset.UIType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->devModeOnly);
          this->__isset.devModeOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->internalOnly);
          this->__isset.internalOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->readOnly);
          this->__isset.readOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isValid);
          this->__isset.isValid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isActive);
          this->__isset.isActive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validation);
          this->__isset.validation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activeDependencies.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->activeDependencies.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->activeDependencies[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.activeDependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionName);
          this->__isset.ActionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionObject);
          this->__isset.ActionObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionOnSetValue);
          this->__isset.ActionOnSetValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionOnGetValue);
          this->__isset.ActionOnGetValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dataList) {
    xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->dataList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.UIType) {
    xfer += oprot->writeFieldBegin("UIType", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->UIType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.devModeOnly) {
    xfer += oprot->writeFieldBegin("devModeOnly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->devModeOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.internalOnly) {
    xfer += oprot->writeFieldBegin("internalOnly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->internalOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readOnly) {
    xfer += oprot->writeFieldBegin("readOnly", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->readOnly);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("isValid", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->isValid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isActive", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->isActive);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validation) {
    xfer += oprot->writeFieldBegin("validation", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->validation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeDependencies) {
    xfer += oprot->writeFieldBegin("activeDependencies", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->activeDependencies.size()));
      std::vector<activeDependency> ::const_iterator _iter48;
      for (_iter48 = this->activeDependencies.begin(); _iter48 != this->activeDependencies.end(); ++_iter48)
      {
        xfer += (*_iter48).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ActionName) {
    xfer += oprot->writeFieldBegin("ActionName", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->ActionName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ActionObject) {
    xfer += oprot->writeFieldBegin("ActionObject", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeString(this->ActionObject);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ActionOnSetValue) {
    xfer += oprot->writeFieldBegin("ActionOnSetValue", ::apache::thrift::protocol::T_STRING, 19);
    xfer += oprot->writeString(this->ActionOnSetValue);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ActionOnGetValue) {
    xfer += oprot->writeFieldBegin("ActionOnGetValue", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->ActionOnGetValue);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingItem &a, SettingItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.dataList, b.dataList);
  swap(a.platform, b.platform);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.UIType, b.UIType);
  swap(a.devModeOnly, b.devModeOnly);
  swap(a.internalOnly, b.internalOnly);
  swap(a.readOnly, b.readOnly);
  swap(a.isValid, b.isValid);
  swap(a.isActive, b.isActive);
  swap(a.validation, b.validation);
  swap(a.activeDependencies, b.activeDependencies);
  swap(a.ActionName, b.ActionName);
  swap(a.ActionObject, b.ActionObject);
  swap(a.ActionOnSetValue, b.ActionOnSetValue);
  swap(a.ActionOnGetValue, b.ActionOnGetValue);
  swap(a.__isset, b.__isset);
}

SettingItem::SettingItem(const SettingItem& other49) {
  id = other49.id;
  display = other49.display;
  dataType = other49.dataType;
  dataValue = other49.dataValue;
  dataList = other49.dataList;
  platform = other49.platform;
  summary = other49.summary;
  description = other49.description;
  UIType = other49.UIType;
  devModeOnly = other49.devModeOnly;
  internalOnly = other49.internalOnly;
  readOnly = other49.readOnly;
  isValid = other49.isValid;
  isActive = other49.isActive;
  validation = other49.validation;
  activeDependencies = other49.activeDependencies;
  ActionName = other49.ActionName;
  ActionObject = other49.ActionObject;
  ActionOnSetValue = other49.ActionOnSetValue;
  ActionOnGetValue = other49.ActionOnGetValue;
  __isset = other49.__isset;
}
SettingItem& SettingItem::operator=(const SettingItem& other50) {
  id = other50.id;
  display = other50.display;
  dataType = other50.dataType;
  dataValue = other50.dataValue;
  dataList = other50.dataList;
  platform = other50.platform;
  summary = other50.summary;
  description = other50.description;
  UIType = other50.UIType;
  devModeOnly = other50.devModeOnly;
  internalOnly = other50.internalOnly;
  readOnly = other50.readOnly;
  isValid = other50.isValid;
  isActive = other50.isActive;
  validation = other50.validation;
  activeDependencies = other50.activeDependencies;
  ActionName = other50.ActionName;
  ActionObject = other50.ActionObject;
  ActionOnSetValue = other50.ActionOnSetValue;
  ActionOnGetValue = other50.ActionOnGetValue;
  __isset = other50.__isset;
  return *this;
}
void SettingItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingItem(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ", " << "dataList="; (__isset.dataList ? (out << to_string(dataList)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "UIType="; (__isset.UIType ? (out << to_string(UIType)) : (out << "<null>"));
  out << ", " << "devModeOnly="; (__isset.devModeOnly ? (out << to_string(devModeOnly)) : (out << "<null>"));
  out << ", " << "internalOnly="; (__isset.internalOnly ? (out << to_string(internalOnly)) : (out << "<null>"));
  out << ", " << "readOnly="; (__isset.readOnly ? (out << to_string(readOnly)) : (out << "<null>"));
  out << ", " << "isValid=" << to_string(isValid);
  out << ", " << "isActive=" << to_string(isActive);
  out << ", " << "validation="; (__isset.validation ? (out << to_string(validation)) : (out << "<null>"));
  out << ", " << "activeDependencies="; (__isset.activeDependencies ? (out << to_string(activeDependencies)) : (out << "<null>"));
  out << ", " << "ActionName="; (__isset.ActionName ? (out << to_string(ActionName)) : (out << "<null>"));
  out << ", " << "ActionObject="; (__isset.ActionObject ? (out << to_string(ActionObject)) : (out << "<null>"));
  out << ", " << "ActionOnSetValue="; (__isset.ActionOnSetValue ? (out << to_string(ActionOnSetValue)) : (out << "<null>"));
  out << ", " << "ActionOnGetValue="; (__isset.ActionOnGetValue ? (out << to_string(ActionOnGetValue)) : (out << "<null>"));
  out << ")";
}


SettingCategory::~SettingCategory() throw() {
}


void SettingCategory::__set_id(const std::string& val) {
  this->id = val;
}

void SettingCategory::__set_display(const std::string& val) {
  this->display = val;
}

void SettingCategory::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingCategory::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingCategory::__set_sortingPriority(const int32_t val) {
  this->sortingPriority = val;
}

void SettingCategory::__set_isSystemCategory(const bool val) {
  this->isSystemCategory = val;
}

void SettingCategory::__set_items(const std::map<std::string, int32_t> & val) {
  this->items = val;
}

void SettingCategory::__set_enable(const bool val) {
  this->enable = val;
}

void SettingCategory::__set_showInUI(const bool val) {
  this->showInUI = val;
}

void SettingCategory::__set_script(const std::string& val) {
  this->script = val;
}
std::ostream& operator<<(std::ostream& out, const SettingCategory& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingCategory::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sortingPriority);
          this->__isset.sortingPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSystemCategory);
          this->__isset.isSystemCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->items.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _ktype52;
            ::apache::thrift::protocol::TType _vtype53;
            xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              std::string _key56;
              xfer += iprot->readString(_key56);
              int32_t& _val57 = this->items[_key56];
              xfer += iprot->readI32(_val57);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->showInUI);
          this->__isset.showInUI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->script);
          this->__isset.script = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingCategory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingCategory");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sortingPriority", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sortingPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSystemCategory", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->isSystemCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->items.size()));
    std::map<std::string, int32_t> ::const_iterator _iter58;
    for (_iter58 = this->items.begin(); _iter58 != this->items.end(); ++_iter58)
    {
      xfer += oprot->writeString(_iter58->first);
      xfer += oprot->writeI32(_iter58->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("showInUI", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->showInUI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("script", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->script);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingCategory &a, SettingCategory &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.sortingPriority, b.sortingPriority);
  swap(a.isSystemCategory, b.isSystemCategory);
  swap(a.items, b.items);
  swap(a.enable, b.enable);
  swap(a.showInUI, b.showInUI);
  swap(a.script, b.script);
  swap(a.__isset, b.__isset);
}

SettingCategory::SettingCategory(const SettingCategory& other59) {
  id = other59.id;
  display = other59.display;
  summary = other59.summary;
  description = other59.description;
  sortingPriority = other59.sortingPriority;
  isSystemCategory = other59.isSystemCategory;
  items = other59.items;
  enable = other59.enable;
  showInUI = other59.showInUI;
  script = other59.script;
  __isset = other59.__isset;
}
SettingCategory& SettingCategory::operator=(const SettingCategory& other60) {
  id = other60.id;
  display = other60.display;
  summary = other60.summary;
  description = other60.description;
  sortingPriority = other60.sortingPriority;
  isSystemCategory = other60.isSystemCategory;
  items = other60.items;
  enable = other60.enable;
  showInUI = other60.showInUI;
  script = other60.script;
  __isset = other60.__isset;
  return *this;
}
void SettingCategory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingCategory(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "sortingPriority=" << to_string(sortingPriority);
  out << ", " << "isSystemCategory=" << to_string(isSystemCategory);
  out << ", " << "items=" << to_string(items);
  out << ", " << "enable=" << to_string(enable);
  out << ", " << "showInUI=" << to_string(showInUI);
  out << ", " << "script=" << to_string(script);
  out << ")";
}


ModuleSetting::~ModuleSetting() throw() {
}


void ModuleSetting::__set_name(const std::string& val) {
  this->name = val;
}

void ModuleSetting::__set_version(const std::string& val) {
  this->version = val;
}

void ModuleSetting::__set_settings(const std::vector<SettingItem> & val) {
  this->settings = val;
}

void ModuleSetting::__set_categories(const std::vector<SettingCategory> & val) {
  this->categories = val;
}
std::ostream& operator<<(std::ostream& out, const ModuleSetting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModuleSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->settings.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->settings.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += this->settings[_i65].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->categories.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->categories.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->categories[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.categories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModuleSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModuleSetting");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->settings.size()));
    std::vector<SettingItem> ::const_iterator _iter71;
    for (_iter71 = this->settings.begin(); _iter71 != this->settings.end(); ++_iter71)
    {
      xfer += (*_iter71).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("categories", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->categories.size()));
    std::vector<SettingCategory> ::const_iterator _iter72;
    for (_iter72 = this->categories.begin(); _iter72 != this->categories.end(); ++_iter72)
    {
      xfer += (*_iter72).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModuleSetting &a, ModuleSetting &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.version, b.version);
  swap(a.settings, b.settings);
  swap(a.categories, b.categories);
  swap(a.__isset, b.__isset);
}

ModuleSetting::ModuleSetting(const ModuleSetting& other73) {
  name = other73.name;
  version = other73.version;
  settings = other73.settings;
  categories = other73.categories;
  __isset = other73.__isset;
}
ModuleSetting& ModuleSetting::operator=(const ModuleSetting& other74) {
  name = other74.name;
  version = other74.version;
  settings = other74.settings;
  categories = other74.categories;
  __isset = other74.__isset;
  return *this;
}
void ModuleSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModuleSetting(";
  out << "name=" << to_string(name);
  out << ", " << "version=" << to_string(version);
  out << ", " << "settings=" << to_string(settings);
  out << ", " << "categories=" << to_string(categories);
  out << ")";
}


AppDataRecord::~AppDataRecord() throw() {
}


void AppDataRecord::__set_id(const std::string& val) {
  this->id = val;
}

void AppDataRecord::__set_content(const SettingValue& val) {
  this->content = val;
}
std::ostream& operator<<(std::ostream& out, const AppDataRecord& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppDataRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->content.read(iprot);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataRecord");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->content.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataRecord &a, AppDataRecord &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.content, b.content);
  swap(a.__isset, b.__isset);
}

AppDataRecord::AppDataRecord(const AppDataRecord& other75) {
  id = other75.id;
  content = other75.content;
  __isset = other75.__isset;
}
AppDataRecord& AppDataRecord::operator=(const AppDataRecord& other76) {
  id = other76.id;
  content = other76.content;
  __isset = other76.__isset;
  return *this;
}
void AppDataRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataRecord(";
  out << "id=" << to_string(id);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


AppDataCollection::~AppDataCollection() throw() {
}


void AppDataCollection::__set_category(const std::string& val) {
  this->category = val;
}

void AppDataCollection::__set_records(const std::vector<AppDataRecord> & val) {
  this->records = val;
}
std::ostream& operator<<(std::ostream& out, const AppDataCollection& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppDataCollection::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->records.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->records.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->records[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.records = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataCollection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataCollection");

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("records", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->records.size()));
    std::vector<AppDataRecord> ::const_iterator _iter82;
    for (_iter82 = this->records.begin(); _iter82 != this->records.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataCollection &a, AppDataCollection &b) {
  using ::std::swap;
  swap(a.category, b.category);
  swap(a.records, b.records);
  swap(a.__isset, b.__isset);
}

AppDataCollection::AppDataCollection(const AppDataCollection& other83) {
  category = other83.category;
  records = other83.records;
  __isset = other83.__isset;
}
AppDataCollection& AppDataCollection::operator=(const AppDataCollection& other84) {
  category = other84.category;
  records = other84.records;
  __isset = other84.__isset;
  return *this;
}
void AppDataCollection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataCollection(";
  out << "category=" << to_string(category);
  out << ", " << "records=" << to_string(records);
  out << ")";
}


AppData::~AppData() throw() {
}


void AppData::__set_appId(const std::string& val) {
  this->appId = val;
}

void AppData::__set_data(const std::vector<AppDataCollection> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const AppData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->data.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->data[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppData");

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<AppDataCollection> ::const_iterator _iter90;
    for (_iter90 = this->data.begin(); _iter90 != this->data.end(); ++_iter90)
    {
      xfer += (*_iter90).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppData &a, AppData &b) {
  using ::std::swap;
  swap(a.appId, b.appId);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

AppData::AppData(const AppData& other91) {
  appId = other91.appId;
  data = other91.data;
  __isset = other91.__isset;
}
AppData& AppData::operator=(const AppData& other92) {
  appId = other92.appId;
  data = other92.data;
  __isset = other92.__isset;
  return *this;
}
void AppData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppData(";
  out << "appId=" << to_string(appId);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


PopupNotification::~PopupNotification() throw() {
}


void PopupNotification::__set_NotificationType(const NotificationType::type val) {
  this->NotificationType = val;
}

void PopupNotification::__set_MainIcon(const std::string& val) {
  this->MainIcon = val;
}

void PopupNotification::__set_Text(const std::string& val) {
  this->Text = val;
}

void PopupNotification::__set_Description(const std::string& val) {
  this->Description = val;
}
std::ostream& operator<<(std::ostream& out, const PopupNotification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PopupNotification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast93;
          xfer += iprot->readI32(ecast93);
          this->NotificationType = (NotificationType::type)ecast93;
          this->__isset.NotificationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->MainIcon);
          this->__isset.MainIcon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Text);
          this->__isset.Text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Description);
          this->__isset.Description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PopupNotification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PopupNotification");

  xfer += oprot->writeFieldBegin("NotificationType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->NotificationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MainIcon", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->MainIcon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Text", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->Text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Description", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->Description);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PopupNotification &a, PopupNotification &b) {
  using ::std::swap;
  swap(a.NotificationType, b.NotificationType);
  swap(a.MainIcon, b.MainIcon);
  swap(a.Text, b.Text);
  swap(a.Description, b.Description);
  swap(a.__isset, b.__isset);
}

PopupNotification::PopupNotification(const PopupNotification& other94) {
  NotificationType = other94.NotificationType;
  MainIcon = other94.MainIcon;
  Text = other94.Text;
  Description = other94.Description;
  __isset = other94.__isset;
}
PopupNotification& PopupNotification::operator=(const PopupNotification& other95) {
  NotificationType = other95.NotificationType;
  MainIcon = other95.MainIcon;
  Text = other95.Text;
  Description = other95.Description;
  __isset = other95.__isset;
  return *this;
}
void PopupNotification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PopupNotification(";
  out << "NotificationType=" << to_string(NotificationType);
  out << ", " << "MainIcon=" << to_string(MainIcon);
  out << ", " << "Text=" << to_string(Text);
  out << ", " << "Description=" << to_string(Description);
  out << ")";
}

}}} // namespace
