/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CommonTypeSDKDataTypes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Ruyi { namespace SDK { namespace CommonType {

int _kLoginStateValues[] = {
  LoginState::Logout,
  LoginState::Login
};
const char* _kLoginStateNames[] = {
  "Logout",
  "Login"
};
const std::map<int, const char*> _LoginState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLoginStateValues, _kLoginStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LoginState::type& val) {
  std::map<int, const char*>::const_iterator it = _LoginState_VALUES_TO_NAMES.find(val);
  if (it != _LoginState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kInputCagetoryValues[] = {
  InputCagetory::RuyiGamePad,
  InputCagetory::KeyboardMouse,
  InputCagetory::XBox360
};
const char* _kInputCagetoryNames[] = {
  "RuyiGamePad",
  "KeyboardMouse",
  "XBox360"
};
const std::map<int, const char*> _InputCagetory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kInputCagetoryValues, _kInputCagetoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const InputCagetory::type& val) {
  std::map<int, const char*>::const_iterator it = _InputCagetory_VALUES_TO_NAMES.find(val);
  if (it != _InputCagetory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kePlatformValues[] = {
  ePlatform::None,
  ePlatform::PC,
  ePlatform::Console,
  ePlatform::All
};
const char* _kePlatformNames[] = {
  "None",
  "PC",
  "Console",
  "All"
};
const std::map<int, const char*> _ePlatform_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kePlatformValues, _kePlatformNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ePlatform::type& val) {
  std::map<int, const char*>::const_iterator it = _ePlatform_VALUES_TO_NAMES.find(val);
  if (it != _ePlatform_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _keUITypeValues[] = {
  eUIType::None,
  eUIType::Toggle,
  eUIType::Text,
  eUIType::Slider,
  eUIType::CheckList,
  eUIType::OptionList,
  eUIType::DateTime,
  eUIType::TextInput
};
const char* _keUITypeNames[] = {
  "None",
  "Toggle",
  "Text",
  "Slider",
  "CheckList",
  "OptionList",
  "DateTime",
  "TextInput"
};
const std::map<int, const char*> _eUIType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _keUITypeValues, _keUITypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const eUIType::type& val) {
  std::map<int, const char*>::const_iterator it = _eUIType_VALUES_TO_NAMES.find(val);
  if (it != _eUIType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


ErrorException::~ErrorException() throw() {
}


void ErrorException::__set_errId(const int32_t val) {
  this->errId = val;
}

void ErrorException::__set_errMsg(const std::string& val) {
  this->errMsg = val;
}
std::ostream& operator<<(std::ostream& out, const ErrorException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ErrorException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errId);
          this->__isset.errId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ErrorException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ErrorException");

  xfer += oprot->writeFieldBegin("errId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->errMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ErrorException &a, ErrorException &b) {
  using ::std::swap;
  swap(a.errId, b.errId);
  swap(a.errMsg, b.errMsg);
  swap(a.__isset, b.__isset);
}

ErrorException::ErrorException(const ErrorException& other0) : TException() {
  errId = other0.errId;
  errMsg = other0.errMsg;
  __isset = other0.__isset;
}
ErrorException& ErrorException::operator=(const ErrorException& other1) {
  errId = other1.errId;
  errMsg = other1.errMsg;
  __isset = other1.__isset;
  return *this;
}
void ErrorException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ErrorException(";
  out << "errId=" << to_string(errId);
  out << ", " << "errMsg=" << to_string(errMsg);
  out << ")";
}

const char* ErrorException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: ErrorException";
  }
}


range::~range() throw() {
}


void range::__set_minimum(const double val) {
  this->minimum = val;
}

void range::__set_maximum(const double val) {
  this->maximum = val;
}
std::ostream& operator<<(std::ostream& out, const range& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t range::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->minimum);
          this->__isset.minimum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->maximum);
          this->__isset.maximum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t range::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("range");

  xfer += oprot->writeFieldBegin("minimum", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->minimum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maximum", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->maximum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(range &a, range &b) {
  using ::std::swap;
  swap(a.minimum, b.minimum);
  swap(a.maximum, b.maximum);
  swap(a.__isset, b.__isset);
}

range::range(const range& other2) {
  minimum = other2.minimum;
  maximum = other2.maximum;
  __isset = other2.__isset;
}
range& range::operator=(const range& other3) {
  minimum = other3.minimum;
  maximum = other3.maximum;
  __isset = other3.__isset;
  return *this;
}
void range::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "range(";
  out << "minimum=" << to_string(minimum);
  out << ", " << "maximum=" << to_string(maximum);
  out << ")";
}


InputModifier::~InputModifier() throw() {
}


void InputModifier::__set_DeadZone(const range& val) {
  this->DeadZone = val;
__isset.DeadZone = true;
}

void InputModifier::__set_Scale(const double val) {
  this->Scale = val;
}
std::ostream& operator<<(std::ostream& out, const InputModifier& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InputModifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->DeadZone.read(iprot);
          this->__isset.DeadZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Scale);
          this->__isset.Scale = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputModifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputModifier");

  if (this->__isset.DeadZone) {
    xfer += oprot->writeFieldBegin("DeadZone", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->DeadZone.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("Scale", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Scale);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputModifier &a, InputModifier &b) {
  using ::std::swap;
  swap(a.DeadZone, b.DeadZone);
  swap(a.Scale, b.Scale);
  swap(a.__isset, b.__isset);
}

InputModifier::InputModifier(const InputModifier& other4) {
  DeadZone = other4.DeadZone;
  Scale = other4.Scale;
  __isset = other4.__isset;
}
InputModifier& InputModifier::operator=(const InputModifier& other5) {
  DeadZone = other5.DeadZone;
  Scale = other5.Scale;
  __isset = other5.__isset;
  return *this;
}
void InputModifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputModifier(";
  out << "DeadZone="; (__isset.DeadZone ? (out << to_string(DeadZone)) : (out << "<null>"));
  out << ", " << "Scale=" << to_string(Scale);
  out << ")";
}


InputIdentifier::~InputIdentifier() throw() {
}


void InputIdentifier::__set_Device(const std::string& val) {
  this->Device = val;
}

void InputIdentifier::__set_Value(const std::string& val) {
  this->Value = val;
}

void InputIdentifier::__set_ActivateEvent(const std::string& val) {
  this->ActivateEvent = val;
__isset.ActivateEvent = true;
}

void InputIdentifier::__set_Modifier(const InputModifier& val) {
  this->Modifier = val;
__isset.Modifier = true;
}
std::ostream& operator<<(std::ostream& out, const InputIdentifier& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InputIdentifier::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Device);
          this->__isset.Device = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActivateEvent);
          this->__isset.ActivateEvent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Modifier.read(iprot);
          this->__isset.Modifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputIdentifier::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputIdentifier");

  xfer += oprot->writeFieldBegin("Device", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Device);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ActivateEvent) {
    xfer += oprot->writeFieldBegin("ActivateEvent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->ActivateEvent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Modifier) {
    xfer += oprot->writeFieldBegin("Modifier", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Modifier.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputIdentifier &a, InputIdentifier &b) {
  using ::std::swap;
  swap(a.Device, b.Device);
  swap(a.Value, b.Value);
  swap(a.ActivateEvent, b.ActivateEvent);
  swap(a.Modifier, b.Modifier);
  swap(a.__isset, b.__isset);
}

InputIdentifier::InputIdentifier(const InputIdentifier& other6) {
  Device = other6.Device;
  Value = other6.Value;
  ActivateEvent = other6.ActivateEvent;
  Modifier = other6.Modifier;
  __isset = other6.__isset;
}
InputIdentifier& InputIdentifier::operator=(const InputIdentifier& other7) {
  Device = other7.Device;
  Value = other7.Value;
  ActivateEvent = other7.ActivateEvent;
  Modifier = other7.Modifier;
  __isset = other7.__isset;
  return *this;
}
void InputIdentifier::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputIdentifier(";
  out << "Device=" << to_string(Device);
  out << ", " << "Value=" << to_string(Value);
  out << ", " << "ActivateEvent="; (__isset.ActivateEvent ? (out << to_string(ActivateEvent)) : (out << "<null>"));
  out << ", " << "Modifier="; (__isset.Modifier ? (out << to_string(Modifier)) : (out << "<null>"));
  out << ")";
}


ActionTriggerInfo::~ActionTriggerInfo() throw() {
}


void ActionTriggerInfo::__set_InputCagetory(const InputCagetory::type val) {
  this->InputCagetory = val;
}

void ActionTriggerInfo::__set_TriggerConditions(const std::vector<InputIdentifier> & val) {
  this->TriggerConditions = val;
}

void ActionTriggerInfo::__set_AutoTrigger(const bool val) {
  this->AutoTrigger = val;
__isset.AutoTrigger = true;
}

void ActionTriggerInfo::__set_TriggerInterval(const int32_t val) {
  this->TriggerInterval = val;
__isset.TriggerInterval = true;
}
std::ostream& operator<<(std::ostream& out, const ActionTriggerInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ActionTriggerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->InputCagetory = (InputCagetory::type)ecast8;
          this->__isset.InputCagetory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->TriggerConditions.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->TriggerConditions.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->TriggerConditions[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.TriggerConditions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AutoTrigger);
          this->__isset.AutoTrigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->TriggerInterval);
          this->__isset.TriggerInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ActionTriggerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ActionTriggerInfo");

  xfer += oprot->writeFieldBegin("InputCagetory", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->InputCagetory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerConditions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->TriggerConditions.size()));
    std::vector<InputIdentifier> ::const_iterator _iter14;
    for (_iter14 = this->TriggerConditions.begin(); _iter14 != this->TriggerConditions.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.AutoTrigger) {
    xfer += oprot->writeFieldBegin("AutoTrigger", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->AutoTrigger);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TriggerInterval) {
    xfer += oprot->writeFieldBegin("TriggerInterval", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->TriggerInterval);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ActionTriggerInfo &a, ActionTriggerInfo &b) {
  using ::std::swap;
  swap(a.InputCagetory, b.InputCagetory);
  swap(a.TriggerConditions, b.TriggerConditions);
  swap(a.AutoTrigger, b.AutoTrigger);
  swap(a.TriggerInterval, b.TriggerInterval);
  swap(a.__isset, b.__isset);
}

ActionTriggerInfo::ActionTriggerInfo(const ActionTriggerInfo& other15) {
  InputCagetory = other15.InputCagetory;
  TriggerConditions = other15.TriggerConditions;
  AutoTrigger = other15.AutoTrigger;
  TriggerInterval = other15.TriggerInterval;
  __isset = other15.__isset;
}
ActionTriggerInfo& ActionTriggerInfo::operator=(const ActionTriggerInfo& other16) {
  InputCagetory = other16.InputCagetory;
  TriggerConditions = other16.TriggerConditions;
  AutoTrigger = other16.AutoTrigger;
  TriggerInterval = other16.TriggerInterval;
  __isset = other16.__isset;
  return *this;
}
void ActionTriggerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ActionTriggerInfo(";
  out << "InputCagetory=" << to_string(InputCagetory);
  out << ", " << "TriggerConditions=" << to_string(TriggerConditions);
  out << ", " << "AutoTrigger="; (__isset.AutoTrigger ? (out << to_string(AutoTrigger)) : (out << "<null>"));
  out << ", " << "TriggerInterval="; (__isset.TriggerInterval ? (out << to_string(TriggerInterval)) : (out << "<null>"));
  out << ")";
}


InputActionInfo::~InputActionInfo() throw() {
}


void InputActionInfo::__set_ActionName(const std::string& val) {
  this->ActionName = val;
}

void InputActionInfo::__set_TriggerInfo(const ActionTriggerInfo& val) {
  this->TriggerInfo = val;
}
std::ostream& operator<<(std::ostream& out, const InputActionInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InputActionInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionName);
          this->__isset.ActionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->TriggerInfo.read(iprot);
          this->__isset.TriggerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InputActionInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InputActionInfo");

  xfer += oprot->writeFieldBegin("ActionName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ActionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("TriggerInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->TriggerInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InputActionInfo &a, InputActionInfo &b) {
  using ::std::swap;
  swap(a.ActionName, b.ActionName);
  swap(a.TriggerInfo, b.TriggerInfo);
  swap(a.__isset, b.__isset);
}

InputActionInfo::InputActionInfo(const InputActionInfo& other17) {
  ActionName = other17.ActionName;
  TriggerInfo = other17.TriggerInfo;
  __isset = other17.__isset;
}
InputActionInfo& InputActionInfo::operator=(const InputActionInfo& other18) {
  ActionName = other18.ActionName;
  TriggerInfo = other18.TriggerInfo;
  __isset = other18.__isset;
  return *this;
}
void InputActionInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InputActionInfo(";
  out << "ActionName=" << to_string(ActionName);
  out << ", " << "TriggerInfo=" << to_string(TriggerInfo);
  out << ")";
}


notification::~notification() throw() {
}


void notification::__set_title(const std::string& val) {
  this->title = val;
}

void notification::__set_detail(const std::string& val) {
  this->detail = val;
}

void notification::__set_option(const std::vector<std::string> & val) {
  this->option = val;
}
std::ostream& operator<<(std::ostream& out, const notification& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t notification::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->detail);
          this->__isset.detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->option.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->option.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->option[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t notification::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("notification");

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("detail", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->detail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->option.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->option.begin(); _iter24 != this->option.end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(notification &a, notification &b) {
  using ::std::swap;
  swap(a.title, b.title);
  swap(a.detail, b.detail);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

notification::notification(const notification& other25) {
  title = other25.title;
  detail = other25.detail;
  option = other25.option;
  __isset = other25.__isset;
}
notification& notification::operator=(const notification& other26) {
  title = other26.title;
  detail = other26.detail;
  option = other26.option;
  __isset = other26.__isset;
  return *this;
}
void notification::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "notification(";
  out << "title=" << to_string(title);
  out << ", " << "detail=" << to_string(detail);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


dataListItem::~dataListItem() throw() {
}


void dataListItem::__set_elementType(const std::string& val) {
  this->elementType = val;
}

void dataListItem::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void dataListItem::__set_removeNotification(const notification& val) {
  this->removeNotification = val;
}
std::ostream& operator<<(std::ostream& out, const dataListItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t dataListItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->elementType);
          this->__isset.elementType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->values.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readString(this->values[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->removeNotification.read(iprot);
          this->__isset.removeNotification = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t dataListItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("dataListItem");

  xfer += oprot->writeFieldBegin("elementType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->elementType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = this->values.begin(); _iter32 != this->values.end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removeNotification", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->removeNotification.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(dataListItem &a, dataListItem &b) {
  using ::std::swap;
  swap(a.elementType, b.elementType);
  swap(a.values, b.values);
  swap(a.removeNotification, b.removeNotification);
  swap(a.__isset, b.__isset);
}

dataListItem::dataListItem(const dataListItem& other33) {
  elementType = other33.elementType;
  values = other33.values;
  removeNotification = other33.removeNotification;
  __isset = other33.__isset;
}
dataListItem& dataListItem::operator=(const dataListItem& other34) {
  elementType = other34.elementType;
  values = other34.values;
  removeNotification = other34.removeNotification;
  __isset = other34.__isset;
  return *this;
}
void dataListItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "dataListItem(";
  out << "elementType=" << to_string(elementType);
  out << ", " << "values=" << to_string(values);
  out << ", " << "removeNotification=" << to_string(removeNotification);
  out << ")";
}


activeDependency::~activeDependency() throw() {
}


void activeDependency::__set_name(const std::string& val) {
  this->name = val;
}

void activeDependency::__set_condition(const std::string& val) {
  this->condition = val;
}
std::ostream& operator<<(std::ostream& out, const activeDependency& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t activeDependency::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->condition);
          this->__isset.condition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t activeDependency::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("activeDependency");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("condition", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->condition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(activeDependency &a, activeDependency &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.condition, b.condition);
  swap(a.__isset, b.__isset);
}

activeDependency::activeDependency(const activeDependency& other35) {
  name = other35.name;
  condition = other35.condition;
  __isset = other35.__isset;
}
activeDependency& activeDependency::operator=(const activeDependency& other36) {
  name = other36.name;
  condition = other36.condition;
  __isset = other36.__isset;
  return *this;
}
void activeDependency::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "activeDependency(";
  out << "name=" << to_string(name);
  out << ", " << "condition=" << to_string(condition);
  out << ")";
}


SettingValue::~SettingValue() throw() {
}


void SettingValue::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingValue::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}
std::ostream& operator<<(std::ostream& out, const SettingValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingValue");

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingValue &a, SettingValue &b) {
  using ::std::swap;
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.__isset, b.__isset);
}

SettingValue::SettingValue(const SettingValue& other37) {
  dataType = other37.dataType;
  dataValue = other37.dataValue;
  __isset = other37.__isset;
}
SettingValue& SettingValue::operator=(const SettingValue& other38) {
  dataType = other38.dataType;
  dataValue = other38.dataValue;
  __isset = other38.__isset;
  return *this;
}
void SettingValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingValue(";
  out << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ")";
}


SettingItem::~SettingItem() throw() {
}


void SettingItem::__set_id(const std::string& val) {
  this->id = val;
}

void SettingItem::__set_display(const std::string& val) {
  this->display = val;
}

void SettingItem::__set_dataType(const std::string& val) {
  this->dataType = val;
}

void SettingItem::__set_dataValue(const std::string& val) {
  this->dataValue = val;
}

void SettingItem::__set_dataList(const dataListItem& val) {
  this->dataList = val;
__isset.dataList = true;
}

void SettingItem::__set_platform(const ePlatform::type val) {
  this->platform = val;
__isset.platform = true;
}

void SettingItem::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingItem::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingItem::__set_UIType(const eUIType::type val) {
  this->UIType = val;
__isset.UIType = true;
}

void SettingItem::__set_devModeOnly(const bool val) {
  this->devModeOnly = val;
__isset.devModeOnly = true;
}

void SettingItem::__set_internalOnly(const bool val) {
  this->internalOnly = val;
__isset.internalOnly = true;
}

void SettingItem::__set_readOnly(const bool val) {
  this->readOnly = val;
__isset.readOnly = true;
}

void SettingItem::__set_isValid(const bool val) {
  this->isValid = val;
}

void SettingItem::__set_isActive(const bool val) {
  this->isActive = val;
}

void SettingItem::__set_validation(const std::string& val) {
  this->validation = val;
__isset.validation = true;
}

void SettingItem::__set_activeDependencies(const std::vector<activeDependency> & val) {
  this->activeDependencies = val;
__isset.activeDependencies = true;
}

void SettingItem::__set_ActionName(const std::string& val) {
  this->ActionName = val;
}

void SettingItem::__set_ActionObject(const std::string& val) {
  this->ActionObject = val;
}

void SettingItem::__set_ActionMethodName(const std::string& val) {
  this->ActionMethodName = val;
}
std::ostream& operator<<(std::ostream& out, const SettingItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataValue);
          this->__isset.dataValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataList.read(iprot);
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast39;
          xfer += iprot->readI32(ecast39);
          this->platform = (ePlatform::type)ecast39;
          this->__isset.platform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->UIType = (eUIType::type)ecast40;
          this->__isset.UIType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->devModeOnly);
          this->__isset.devModeOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->internalOnly);
          this->__isset.internalOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->readOnly);
          this->__isset.readOnly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isValid);
          this->__isset.isValid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isActive);
          this->__isset.isActive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->validation);
          this->__isset.validation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->activeDependencies.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->activeDependencies.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += this->activeDependencies[_i45].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.activeDependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionName);
          this->__isset.ActionName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionObject);
          this->__isset.ActionObject = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ActionMethodName);
          this->__isset.ActionMethodName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingItem");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataValue", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dataValue);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dataList) {
    xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->dataList.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.platform) {
    xfer += oprot->writeFieldBegin("platform", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->platform);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.UIType) {
    xfer += oprot->writeFieldBegin("UIType", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32((int32_t)this->UIType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.devModeOnly) {
    xfer += oprot->writeFieldBegin("devModeOnly", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->devModeOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.internalOnly) {
    xfer += oprot->writeFieldBegin("internalOnly", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->internalOnly);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.readOnly) {
    xfer += oprot->writeFieldBegin("readOnly", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->readOnly);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("isValid", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->isValid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isActive", ::apache::thrift::protocol::T_BOOL, 14);
  xfer += oprot->writeBool(this->isActive);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.validation) {
    xfer += oprot->writeFieldBegin("validation", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->validation);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.activeDependencies) {
    xfer += oprot->writeFieldBegin("activeDependencies", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->activeDependencies.size()));
      std::vector<activeDependency> ::const_iterator _iter46;
      for (_iter46 = this->activeDependencies.begin(); _iter46 != this->activeDependencies.end(); ++_iter46)
      {
        xfer += (*_iter46).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ActionName", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->ActionName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ActionObject", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->ActionObject);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ActionMethodName", ::apache::thrift::protocol::T_STRING, 19);
  xfer += oprot->writeString(this->ActionMethodName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingItem &a, SettingItem &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.dataType, b.dataType);
  swap(a.dataValue, b.dataValue);
  swap(a.dataList, b.dataList);
  swap(a.platform, b.platform);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.UIType, b.UIType);
  swap(a.devModeOnly, b.devModeOnly);
  swap(a.internalOnly, b.internalOnly);
  swap(a.readOnly, b.readOnly);
  swap(a.isValid, b.isValid);
  swap(a.isActive, b.isActive);
  swap(a.validation, b.validation);
  swap(a.activeDependencies, b.activeDependencies);
  swap(a.ActionName, b.ActionName);
  swap(a.ActionObject, b.ActionObject);
  swap(a.ActionMethodName, b.ActionMethodName);
  swap(a.__isset, b.__isset);
}

SettingItem::SettingItem(const SettingItem& other47) {
  id = other47.id;
  display = other47.display;
  dataType = other47.dataType;
  dataValue = other47.dataValue;
  dataList = other47.dataList;
  platform = other47.platform;
  summary = other47.summary;
  description = other47.description;
  UIType = other47.UIType;
  devModeOnly = other47.devModeOnly;
  internalOnly = other47.internalOnly;
  readOnly = other47.readOnly;
  isValid = other47.isValid;
  isActive = other47.isActive;
  validation = other47.validation;
  activeDependencies = other47.activeDependencies;
  ActionName = other47.ActionName;
  ActionObject = other47.ActionObject;
  ActionMethodName = other47.ActionMethodName;
  __isset = other47.__isset;
}
SettingItem& SettingItem::operator=(const SettingItem& other48) {
  id = other48.id;
  display = other48.display;
  dataType = other48.dataType;
  dataValue = other48.dataValue;
  dataList = other48.dataList;
  platform = other48.platform;
  summary = other48.summary;
  description = other48.description;
  UIType = other48.UIType;
  devModeOnly = other48.devModeOnly;
  internalOnly = other48.internalOnly;
  readOnly = other48.readOnly;
  isValid = other48.isValid;
  isActive = other48.isActive;
  validation = other48.validation;
  activeDependencies = other48.activeDependencies;
  ActionName = other48.ActionName;
  ActionObject = other48.ActionObject;
  ActionMethodName = other48.ActionMethodName;
  __isset = other48.__isset;
  return *this;
}
void SettingItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingItem(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "dataValue=" << to_string(dataValue);
  out << ", " << "dataList="; (__isset.dataList ? (out << to_string(dataList)) : (out << "<null>"));
  out << ", " << "platform="; (__isset.platform ? (out << to_string(platform)) : (out << "<null>"));
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "UIType="; (__isset.UIType ? (out << to_string(UIType)) : (out << "<null>"));
  out << ", " << "devModeOnly="; (__isset.devModeOnly ? (out << to_string(devModeOnly)) : (out << "<null>"));
  out << ", " << "internalOnly="; (__isset.internalOnly ? (out << to_string(internalOnly)) : (out << "<null>"));
  out << ", " << "readOnly="; (__isset.readOnly ? (out << to_string(readOnly)) : (out << "<null>"));
  out << ", " << "isValid=" << to_string(isValid);
  out << ", " << "isActive=" << to_string(isActive);
  out << ", " << "validation="; (__isset.validation ? (out << to_string(validation)) : (out << "<null>"));
  out << ", " << "activeDependencies="; (__isset.activeDependencies ? (out << to_string(activeDependencies)) : (out << "<null>"));
  out << ", " << "ActionName=" << to_string(ActionName);
  out << ", " << "ActionObject=" << to_string(ActionObject);
  out << ", " << "ActionMethodName=" << to_string(ActionMethodName);
  out << ")";
}


SettingCategory::~SettingCategory() throw() {
}


void SettingCategory::__set_id(const std::string& val) {
  this->id = val;
}

void SettingCategory::__set_display(const std::string& val) {
  this->display = val;
}

void SettingCategory::__set_summary(const std::string& val) {
  this->summary = val;
__isset.summary = true;
}

void SettingCategory::__set_description(const std::string& val) {
  this->description = val;
__isset.description = true;
}

void SettingCategory::__set_sortingPriority(const int32_t val) {
  this->sortingPriority = val;
}

void SettingCategory::__set_isSystemCategory(const bool val) {
  this->isSystemCategory = val;
}

void SettingCategory::__set_items(const std::map<std::string, int32_t> & val) {
  this->items = val;
}

void SettingCategory::__set_enable(const bool val) {
  this->enable = val;
}

void SettingCategory::__set_showInUI(const bool val) {
  this->showInUI = val;
}
std::ostream& operator<<(std::ostream& out, const SettingCategory& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SettingCategory::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display);
          this->__isset.display = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          this->__isset.summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->description);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sortingPriority);
          this->__isset.sortingPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isSystemCategory);
          this->__isset.isSystemCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->items.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _ktype50;
            ::apache::thrift::protocol::TType _vtype51;
            xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              std::string _key54;
              xfer += iprot->readString(_key54);
              int32_t& _val55 = this->items[_key54];
              xfer += iprot->readI32(_val55);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->showInUI);
          this->__isset.showInUI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SettingCategory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SettingCategory");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("display", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->display);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.summary) {
    xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->summary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.description) {
    xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->description);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sortingPriority", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sortingPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSystemCategory", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->isSystemCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->items.size()));
    std::map<std::string, int32_t> ::const_iterator _iter56;
    for (_iter56 = this->items.begin(); _iter56 != this->items.end(); ++_iter56)
    {
      xfer += oprot->writeString(_iter56->first);
      xfer += oprot->writeI32(_iter56->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("showInUI", ::apache::thrift::protocol::T_BOOL, 9);
  xfer += oprot->writeBool(this->showInUI);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SettingCategory &a, SettingCategory &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.display, b.display);
  swap(a.summary, b.summary);
  swap(a.description, b.description);
  swap(a.sortingPriority, b.sortingPriority);
  swap(a.isSystemCategory, b.isSystemCategory);
  swap(a.items, b.items);
  swap(a.enable, b.enable);
  swap(a.showInUI, b.showInUI);
  swap(a.__isset, b.__isset);
}

SettingCategory::SettingCategory(const SettingCategory& other57) {
  id = other57.id;
  display = other57.display;
  summary = other57.summary;
  description = other57.description;
  sortingPriority = other57.sortingPriority;
  isSystemCategory = other57.isSystemCategory;
  items = other57.items;
  enable = other57.enable;
  showInUI = other57.showInUI;
  __isset = other57.__isset;
}
SettingCategory& SettingCategory::operator=(const SettingCategory& other58) {
  id = other58.id;
  display = other58.display;
  summary = other58.summary;
  description = other58.description;
  sortingPriority = other58.sortingPriority;
  isSystemCategory = other58.isSystemCategory;
  items = other58.items;
  enable = other58.enable;
  showInUI = other58.showInUI;
  __isset = other58.__isset;
  return *this;
}
void SettingCategory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SettingCategory(";
  out << "id=" << to_string(id);
  out << ", " << "display=" << to_string(display);
  out << ", " << "summary="; (__isset.summary ? (out << to_string(summary)) : (out << "<null>"));
  out << ", " << "description="; (__isset.description ? (out << to_string(description)) : (out << "<null>"));
  out << ", " << "sortingPriority=" << to_string(sortingPriority);
  out << ", " << "isSystemCategory=" << to_string(isSystemCategory);
  out << ", " << "items=" << to_string(items);
  out << ", " << "enable=" << to_string(enable);
  out << ", " << "showInUI=" << to_string(showInUI);
  out << ")";
}


ModuleSetting::~ModuleSetting() throw() {
}


void ModuleSetting::__set_name(const std::string& val) {
  this->name = val;
}

void ModuleSetting::__set_version(const std::string& val) {
  this->version = val;
}

void ModuleSetting::__set_settings(const std::vector<SettingItem> & val) {
  this->settings = val;
}

void ModuleSetting::__set_categories(const std::vector<SettingCategory> & val) {
  this->categories = val;
}
std::ostream& operator<<(std::ostream& out, const ModuleSetting& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ModuleSetting::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->settings.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->settings.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += this->settings[_i63].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.settings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->categories.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->categories.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->categories[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.categories = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ModuleSetting::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ModuleSetting");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("settings", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->settings.size()));
    std::vector<SettingItem> ::const_iterator _iter69;
    for (_iter69 = this->settings.begin(); _iter69 != this->settings.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("categories", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->categories.size()));
    std::vector<SettingCategory> ::const_iterator _iter70;
    for (_iter70 = this->categories.begin(); _iter70 != this->categories.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ModuleSetting &a, ModuleSetting &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.version, b.version);
  swap(a.settings, b.settings);
  swap(a.categories, b.categories);
  swap(a.__isset, b.__isset);
}

ModuleSetting::ModuleSetting(const ModuleSetting& other71) {
  name = other71.name;
  version = other71.version;
  settings = other71.settings;
  categories = other71.categories;
  __isset = other71.__isset;
}
ModuleSetting& ModuleSetting::operator=(const ModuleSetting& other72) {
  name = other72.name;
  version = other72.version;
  settings = other72.settings;
  categories = other72.categories;
  __isset = other72.__isset;
  return *this;
}
void ModuleSetting::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ModuleSetting(";
  out << "name=" << to_string(name);
  out << ", " << "version=" << to_string(version);
  out << ", " << "settings=" << to_string(settings);
  out << ", " << "categories=" << to_string(categories);
  out << ")";
}


AppDataRecord::~AppDataRecord() throw() {
}


void AppDataRecord::__set_id(const std::string& val) {
  this->id = val;
}

void AppDataRecord::__set_content(const SettingValue& val) {
  this->content = val;
}
std::ostream& operator<<(std::ostream& out, const AppDataRecord& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppDataRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->content.read(iprot);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataRecord");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->content.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataRecord &a, AppDataRecord &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.content, b.content);
  swap(a.__isset, b.__isset);
}

AppDataRecord::AppDataRecord(const AppDataRecord& other73) {
  id = other73.id;
  content = other73.content;
  __isset = other73.__isset;
}
AppDataRecord& AppDataRecord::operator=(const AppDataRecord& other74) {
  id = other74.id;
  content = other74.content;
  __isset = other74.__isset;
  return *this;
}
void AppDataRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataRecord(";
  out << "id=" << to_string(id);
  out << ", " << "content=" << to_string(content);
  out << ")";
}


AppDataCollection::~AppDataCollection() throw() {
}


void AppDataCollection::__set_category(const std::string& val) {
  this->category = val;
}

void AppDataCollection::__set_records(const std::vector<AppDataRecord> & val) {
  this->records = val;
}
std::ostream& operator<<(std::ostream& out, const AppDataCollection& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppDataCollection::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->category);
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->records.clear();
            uint32_t _size75;
            ::apache::thrift::protocol::TType _etype78;
            xfer += iprot->readListBegin(_etype78, _size75);
            this->records.resize(_size75);
            uint32_t _i79;
            for (_i79 = 0; _i79 < _size75; ++_i79)
            {
              xfer += this->records[_i79].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.records = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppDataCollection::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppDataCollection");

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->category);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("records", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->records.size()));
    std::vector<AppDataRecord> ::const_iterator _iter80;
    for (_iter80 = this->records.begin(); _iter80 != this->records.end(); ++_iter80)
    {
      xfer += (*_iter80).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppDataCollection &a, AppDataCollection &b) {
  using ::std::swap;
  swap(a.category, b.category);
  swap(a.records, b.records);
  swap(a.__isset, b.__isset);
}

AppDataCollection::AppDataCollection(const AppDataCollection& other81) {
  category = other81.category;
  records = other81.records;
  __isset = other81.__isset;
}
AppDataCollection& AppDataCollection::operator=(const AppDataCollection& other82) {
  category = other82.category;
  records = other82.records;
  __isset = other82.__isset;
  return *this;
}
void AppDataCollection::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppDataCollection(";
  out << "category=" << to_string(category);
  out << ", " << "records=" << to_string(records);
  out << ")";
}


AppData::~AppData() throw() {
}


void AppData::__set_appId(const std::string& val) {
  this->appId = val;
}

void AppData::__set_data(const std::vector<AppDataCollection> & val) {
  this->data = val;
}
std::ostream& operator<<(std::ostream& out, const AppData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AppData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->appId);
          this->__isset.appId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->data.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += this->data[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AppData");

  xfer += oprot->writeFieldBegin("appId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->appId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
    std::vector<AppDataCollection> ::const_iterator _iter88;
    for (_iter88 = this->data.begin(); _iter88 != this->data.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AppData &a, AppData &b) {
  using ::std::swap;
  swap(a.appId, b.appId);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

AppData::AppData(const AppData& other89) {
  appId = other89.appId;
  data = other89.data;
  __isset = other89.__isset;
}
AppData& AppData::operator=(const AppData& other90) {
  appId = other90.appId;
  data = other90.data;
  __isset = other90.__isset;
  return *this;
}
void AppData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AppData(";
  out << "appId=" << to_string(appId);
  out << ", " << "data=" << to_string(data);
  out << ")";
}

}}} // namespace
