// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "LocalizationService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::Ruyi::SDK::LocalizationService;

class LocalizationServiceHandler : virtual public LocalizationServiceIf {
 public:
  LocalizationServiceHandler() {
    // Your initialization goes here
  }

  /**
   * Switch language to specified one.
   * 
   * @param language Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN
   * 
   * @param loadAllContext Whether or not to load all context of the language
   * 
   * @param removeOld Whether or not to remove old language
   */
  bool SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld) {
    // Your implementation goes here
    printf("SwitchLanguage\n");
  }

  /**
   * Get currently active language
   */
  void GetCurrentLanguage(std::string& _return) {
    // Your implementation goes here
    printf("GetCurrentLanguage\n");
  }

  /**
   * Switch a context of the language.
   * 
   * @param context Which context to switch to.
   * 
   * @param language Which language that the context belong to
   */
  bool SwitchContext(const std::string& context, const std::string& language) {
    // Your implementation goes here
    printf("SwitchContext\n");
  }

  /**
   * Get currently active context.
   */
  void HintContext(std::string& _return) {
    // Your implementation goes here
    printf("HintContext\n");
  }

  /**
   * Get a localization string.
   * Return: localization string.
   * 
   * @param key The key of the string
   * 
   * @param context The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
   * 
   * @param language The language to search
   */
  void GetString(std::string& _return, const std::string& key, const std::string& context, const std::string& language) {
    // Your implementation goes here
    printf("GetString\n");
  }

  /**
   * Get a set of localization string.
   * 
   * @param filter A regular expresion used to filter the strings
   * 
   * @param context The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
   * 
   * @param language The language to search
   */
  void GetStrings(std::map<std::string, std::string> & _return, const std::string& filter, const std::string& context, const std::string& language) {
    // Your implementation goes here
    printf("GetStrings\n");
  }

  /**
   * Get the file name/path in the language.
   * 
   * The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
   * 
   * @param filename File name with the path to the language pack root.
   * 
   * @param isVirtualPath True to get the virtual path, false to get the exact path to the file.
   * 
   * @param context The context of the file. If null, then while use system context "com.ruyi"
   */
  void GetFileName(std::string& _return, const std::string& filename, const bool isVirtualPath, const std::string& context) {
    // Your implementation goes here
    printf("GetFileName\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<LocalizationServiceHandler> handler(new LocalizationServiceHandler());
  shared_ptr<TProcessor> processor(new LocalizationServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

