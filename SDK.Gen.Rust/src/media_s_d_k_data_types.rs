// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MediaTask {
  NONE = 0,
  PLAYBACK = 1,
  QUERY = 2,
  ALL = 3,
}

impl MediaTask {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MediaTask> {
    let enum_value = i_prot.read_i32()?;
    MediaTask::try_from(enum_value)  }
}

impl TryFrom<i32> for MediaTask {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(MediaTask::NONE),
      1 => Ok(MediaTask::PLAYBACK),
      2 => Ok(MediaTask::QUERY),
      3 => Ok(MediaTask::ALL),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MediaTask", i)
            )
          )
        )
      },
    }
  }
}

/// See System.IO.WatcherChangeTypes
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MediaFileEventTypes {
  NONE = 0,
  CREATED = 1,
  DELETED = 2,
  CHANGED = 4,
  RENAMED = 8,
}

impl MediaFileEventTypes {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MediaFileEventTypes> {
    let enum_value = i_prot.read_i32()?;
    MediaFileEventTypes::try_from(enum_value)  }
}

impl TryFrom<i32> for MediaFileEventTypes {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(MediaFileEventTypes::NONE),
      1 => Ok(MediaFileEventTypes::CREATED),
      2 => Ok(MediaFileEventTypes::DELETED),
      4 => Ok(MediaFileEventTypes::CHANGED),
      8 => Ok(MediaFileEventTypes::RENAMED),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MediaFileEventTypes", i)
            )
          )
        )
      },
    }
  }
}

pub type _int = i32;

//
// MediaFile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MediaFile {
  pub name: Option<String>,
}

impl MediaFile {
  pub fn new<F1>(name: F1) -> MediaFile where F1: Into<Option<String>> {
    MediaFile {
      name: name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MediaFile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MediaFile {
      name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MediaFile");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MediaFile {
  fn default() -> Self {
    MediaFile{
      name: Some("".to_owned()),
    }
  }
}

//
// PlayMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PlayMsg {
  pub url: Option<String>,
}

impl PlayMsg {
  pub fn new<F1>(url: F1) -> PlayMsg where F1: Into<Option<String>> {
    PlayMsg {
      url: url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PlayMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PlayMsg {
      url: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.url {
      o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PlayMsg {
  fn default() -> Self {
    PlayMsg{
      url: Some("".to_owned()),
    }
  }
}

//
// PauseMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PauseMsg {
  pub url: Option<String>,
}

impl PauseMsg {
  pub fn new<F1>(url: F1) -> PauseMsg where F1: Into<Option<String>> {
    PauseMsg {
      url: url.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PauseMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PauseMsg {
      url: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PauseMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.url {
      o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PauseMsg {
  fn default() -> Self {
    PauseMsg{
      url: Some("".to_owned()),
    }
  }
}

//
// StopMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StopMsg {
  pub name: Option<MediaTask>,
}

impl StopMsg {
  pub fn new<F1>(name: F1) -> StopMsg where F1: Into<Option<MediaTask>> {
    StopMsg {
      name: name.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<StopMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MediaTask> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MediaTask::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StopMsg {
      name: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StopMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for StopMsg {
  fn default() -> Self {
    StopMsg{
      name: None,
    }
  }
}

//
// AddPathMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AddPathMsg {
  pub path: Option<String>,
  pub pattern: Option<String>,
}

impl AddPathMsg {
  pub fn new<F1, F2>(path: F1, pattern: F2) -> AddPathMsg where F1: Into<Option<String>>, F2: Into<Option<String>> {
    AddPathMsg {
      path: path.into(),
      pattern: pattern.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AddPathMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AddPathMsg {
      path: f_1,
      pattern: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AddPathMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pattern {
      o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AddPathMsg {
  fn default() -> Self {
    AddPathMsg{
      path: Some("".to_owned()),
      pattern: Some("".to_owned()),
    }
  }
}

//
// RemovePathMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RemovePathMsg {
  pub path: Option<String>,
}

impl RemovePathMsg {
  pub fn new<F1>(path: F1) -> RemovePathMsg where F1: Into<Option<String>> {
    RemovePathMsg {
      path: path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RemovePathMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RemovePathMsg {
      path: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemovePathMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RemovePathMsg {
  fn default() -> Self {
    RemovePathMsg{
      path: Some("".to_owned()),
    }
  }
}

//
// QueryMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryMsg {
  pub path: Option<String>,
  pub pattern: Option<String>,
}

impl QueryMsg {
  pub fn new<F1, F2>(path: F1, pattern: F2) -> QueryMsg where F1: Into<Option<String>>, F2: Into<Option<String>> {
    QueryMsg {
      path: path.into(),
      pattern: pattern.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<QueryMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryMsg {
      path: f_1,
      pattern: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.pattern {
      o_prot.write_field_begin(&TFieldIdentifier::new("pattern", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for QueryMsg {
  fn default() -> Self {
    QueryMsg{
      path: Some("".to_owned()),
      pattern: Some("".to_owned()),
    }
  }
}

//
// QueryResultMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryResultMsg {
  /// Query results.  If empty it means query has completed.
  pub files: Option<Vec<MediaFile>>,
}

impl QueryResultMsg {
  pub fn new<F1>(files: F1) -> QueryResultMsg where F1: Into<Option<Vec<MediaFile>>> {
    QueryResultMsg {
      files: files.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<QueryResultMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<MediaFile>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<MediaFile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = MediaFile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryResultMsg {
      files: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryResultMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.files {
      o_prot.write_field_begin(&TFieldIdentifier::new("files", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for QueryResultMsg {
  fn default() -> Self {
    QueryResultMsg{
      files: Some(Vec::new()),
    }
  }
}

//
// PlaybackProgressMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PlaybackProgressMsg {
  pub url: Option<String>,
  pub current_time: Option<OrderedFloat<f64>>,
  pub total_time: Option<OrderedFloat<f64>>,
}

impl PlaybackProgressMsg {
  pub fn new<F1, F2, F3>(url: F1, current_time: F2, total_time: F3) -> PlaybackProgressMsg where F1: Into<Option<String>>, F2: Into<Option<OrderedFloat<f64>>>, F3: Into<Option<OrderedFloat<f64>>> {
    PlaybackProgressMsg {
      url: url.into(),
      current_time: current_time.into(),
      total_time: total_time.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PlaybackProgressMsg> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_3: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PlaybackProgressMsg {
      url: f_1,
      current_time: f_2,
      total_time: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackProgressMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.url {
      o_prot.write_field_begin(&TFieldIdentifier::new("url", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.current_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("CurrentTime", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.total_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("TotalTime", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for PlaybackProgressMsg {
  fn default() -> Self {
    PlaybackProgressMsg{
      url: Some("".to_owned()),
      current_time: Some(OrderedFloat::from(0.0)),
      total_time: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// MediaFileEvent
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MediaFileEvent {
  pub file: Option<MediaFile>,
  pub event: Option<MediaFileEventTypes>,
  pub oldname: Option<String>,
}

impl MediaFileEvent {
  pub fn new<F1, F2, F3>(file: F1, event: F2, oldname: F3) -> MediaFileEvent where F1: Into<Option<MediaFile>>, F2: Into<Option<MediaFileEventTypes>>, F3: Into<Option<String>> {
    MediaFileEvent {
      file: file.into(),
      event: event.into(),
      oldname: oldname.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MediaFileEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<MediaFile> = None;
    let mut f_2: Option<MediaFileEventTypes> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = MediaFile::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = MediaFileEventTypes::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MediaFileEvent {
      file: f_1,
      event: f_2,
      oldname: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MediaFileEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file {
      o_prot.write_field_begin(&TFieldIdentifier::new("file", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.event {
      o_prot.write_field_begin(&TFieldIdentifier::new("event", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.oldname {
      o_prot.write_field_begin(&TFieldIdentifier::new("oldname", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for MediaFileEvent {
  fn default() -> Self {
    MediaFileEvent{
      file: None,
      event: None,
      oldname: Some("".to_owned()),
    }
  }
}

//
// RequestMsg
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RequestMsg {
  Play(PlayMsg),
  Pause(PauseMsg),
  Stop(StopMsg),
  AddPath(AddPathMsg),
  RemovePath(RemovePathMsg),
  Query(QueryMsg),
}

impl RequestMsg {
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RequestMsg> {
    let mut ret: Option<RequestMsg> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PlayMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::Play(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = PauseMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::Pause(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = StopMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::Stop(val));
          }
          received_field_count += 1;
        },
        4 => {
          let val = AddPathMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::AddPath(val));
          }
          received_field_count += 1;
        },
        5 => {
          let val = RemovePathMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::RemovePath(val));
          }
          received_field_count += 1;
        },
        6 => {
          let val = QueryMsg::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(RequestMsg::Query(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote RequestMsg"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote RequestMsg"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestMsg");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      RequestMsg::Play(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("Play", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      RequestMsg::Pause(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("Pause", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      RequestMsg::Stop(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("Stop", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      RequestMsg::AddPath(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("AddPath", TType::Struct, 4))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      RequestMsg::RemovePath(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("RemovePath", TType::Struct, 5))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      RequestMsg::Query(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("Query", TType::Struct, 6))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

